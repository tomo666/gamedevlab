"use strict";(self.webpackChunkgb_studio_xv_plugins_docs=self.webpackChunkgb_studio_xv_plugins_docs||[]).push([[339],{1335:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>m,contentTitle:()=>h,default:()=>v,frontMatter:()=>d,metadata:()=>u,toc:()=>p});var n=s(4848),i=s(8453);const o=s.p+"assets/images/smooth_movement_off_480p-157384838c7bc41162bb29e54284edb8.gif",r=s.p+"assets/images/smooth_movement_on_480p-e9279981ff503cf8fedba4e77f5e49d0.gif",a=s.p+"assets/images/reverse_dir_on_end_reached_480p-6d40ede0764bad44598dd776660287a0.gif",l=s.p+"assets/images/move_to_opposite_480p-9e820593edecb37369dbbc7f955e93b9.gif",c=s.p+"assets/images/cursor_option_bounce_480p-b8e0b23c575460e11348ae3339b4fefd.gif",d={sidebar_position:1},h="Cursor Controller",u={id:"gbs_plugins/docs/cursor_controller",title:"Cursor Controller",description:'Lets you control a selection cursor sprite with animations in a "quick and dirty" way.',source:"@site/docs/gbs_plugins/docs/cursor_controller.md",sourceDirName:"gbs_plugins/docs",slug:"/gbs_plugins/docs/cursor_controller",permalink:"/tomo666/gamedevlab/gbs_plugins/docs/cursor_controller",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"gbsPluginsSidebar",previous:{title:"Plugins",permalink:"/tomo666/gamedevlab/category/plugins"},next:{title:"Array Manager (Set Value)",permalink:"/tomo666/gamedevlab/gbs_plugins/docs/array_manager_set"}},m={},p=[{value:"Description",id:"description",level:2},{value:"<code>[Actor &amp; States] Tab</code>",id:"actor--states-tab",level:3},{value:"<em>Cursor Actor (Default State)</em>",id:"cursor-actor-default-state",level:3},{value:"<em>State: Activated (Play Once)</em>",id:"state-activated-play-once",level:3},{value:"<em>State: Enter Item (Play Once)</em>",id:"state-enter-item-play-once",level:3},{value:"<em>State: Cancel (Play Once)</em>",id:"state-cancel-play-once",level:3},{value:"<em>State: Selected (Play Once)</em>",id:"state-selected-play-once",level:3},{value:"<em>State: Selected-Stay (Play Loop)</em>",id:"state-selected-stay-play-loop",level:3},{value:"<code>[Boundaries] Tab</code>",id:"boundaries-tab",level:3},{value:"<em>Base Pos X</em>",id:"base-pos-x",level:3},{value:"<em>Base Pos Y</em>",id:"base-pos-y",level:3},{value:"<em>Offset Pos X</em>",id:"offset-pos-x",level:3},{value:"<em>Offset Pos Y</em>",id:"offset-pos-y",level:3},{value:"<em>Move Step X</em>",id:"move-step-x",level:3},{value:"<em>Move Step Y</em>",id:"move-step-y",level:3},{value:"<em>Max Columns</em>",id:"max-columns",level:3},{value:"<em>Max Rows</em>",id:"max-rows",level:3},{value:"<em>Use Scene Collisions For Moveable Region</em>",id:"use-scene-collisions-for-moveable-region",level:3},{value:"<em>Collision Tile Start X</em>",id:"collision-tile-start-x",level:3},{value:"<em>Collision Tile Start Y</em>",id:"collision-tile-start-y",level:3},{value:"<code>[Options] Tab</code>",id:"options-tab",level:3},{value:"<em>Smooth movement</em>",id:"smooth-movement",level:3},{value:"<em>Reverse direction on end reached</em>",id:"reverse-direction-on-end-reached",level:3},{value:"<em>Move to opposite side beyond boundary</em>",id:"move-to-opposite-side-beyond-boundary",level:3},{value:"<em>Bounce at dead end</em>",id:"bounce-at-dead-end",level:3},{value:"<em>Move while D-pad held</em>",id:"move-while-d-pad-held",level:3},{value:"<em>Enable &#39;A&#39; button held</em>",id:"enable-a-button-held",level:3},{value:"<em>Change cursor index instantly</em>",id:"change-cursor-index-instantly",level:3},{value:"<em>Show cursor above overlay</em>",id:"show-cursor-above-overlay",level:3},{value:"<code>[Return Values] Tab</code>",id:"return-values-tab",level:3},{value:"<em>Store A/B results to</em>",id:"store-ab-results-to",level:3},{value:"<em>Store current index to</em>",id:"store-current-index-to",level:3}];function x(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",p:"p",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"cursor-controller",children:"Cursor Controller"})}),"\n",(0,n.jsxs)(t.p,{children:["Lets you control a selection cursor sprite with animations in a ",(0,n.jsx)(t.em,{children:'"quick and dirty"'})," way."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Cursor Controller Overview",src:s(2194).A+"",width:"256",height:"230"})}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"This plugin only supports 8x8 tile size mode."})}),"\n",(0,n.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,n.jsx)(t.p,{children:"This plugin provides a method for setting up and controlling a selection cursor using an actor with several animation states that change based on cursor actions or movements. It detects user input via the D-pad or buttons and returns the current cursor\u2019s item index according to the user\u2019s actions. This functionality is intended to be used within the actor\u2019s [On Update] event."}),"\n",(0,n.jsx)(t.p,{children:"Please note, when I refer to \u201cquick and dirty\u201d, it indicates that this plugin may negatively impact game performance depending on how it is used. The underlying logic is somewhat complex due to its increased functional versatility, which means allowing multiple options for tweaking the plugin can significantly slow down your game under certain conditions."}),"\n",(0,n.jsx)(t.h3,{id:"actor--states-tab",children:(0,n.jsx)(t.code,{children:"[Actor & States] Tab"})}),"\n",(0,n.jsx)(t.p,{children:"The [Actor & States] tab lets you specify the default actor to be used as the selection cursor. You can also set different animation states of the same actor sprite that automatically changes depending on the selected action (move, accept, cancel, etc)."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Actor &amp; States Tab",src:s(7259).A+"",width:"459",height:"301"})}),"\n",(0,n.jsx)(t.h3,{id:"cursor-actor-default-state",children:(0,n.jsx)(t.em,{children:"Cursor Actor (Default State)"})}),"\n",(0,n.jsx)(t.p,{children:"The selection cursor actor in its default state. This is the looping animation where the actor is in its idle state (when user is not pressing any buttons)."}),"\n",(0,n.jsx)(t.h3,{id:"state-activated-play-once",children:(0,n.jsx)(t.em,{children:"State: Activated (Play Once)"})}),"\n",(0,n.jsx)(t.p,{children:"Specify the actor's animation state when the cursor is activated."}),"\n",(0,n.jsx)(t.h3,{id:"state-enter-item-play-once",children:(0,n.jsx)(t.em,{children:"State: Enter Item (Play Once)"})}),"\n",(0,n.jsx)(t.p,{children:"Specify the actor's animation state to be used when entered into a different item from the current one. In other words, this state is triggered when cursor index changes."}),"\n",(0,n.jsx)(t.h3,{id:"state-cancel-play-once",children:(0,n.jsx)(t.em,{children:"State: Cancel (Play Once)"})}),"\n",(0,n.jsx)(t.p,{children:"The selection cursor animation state when user cancels the selection mode. This is triggered when the user presses the B button."}),"\n",(0,n.jsx)(t.h3,{id:"state-selected-play-once",children:(0,n.jsx)(t.em,{children:"State: Selected (Play Once)"})}),"\n",(0,n.jsx)(t.p,{children:"Specify the actor's animation state to be used when the item is selected. This is triggered when the user presses the A button."}),"\n",(0,n.jsx)(t.h3,{id:"state-selected-stay-play-loop",children:(0,n.jsx)(t.em,{children:"State: Selected-Stay (Play Loop)"})}),"\n",(0,n.jsx)(t.p,{children:"Specify the actor's animation state to be used when the item is selected, and cursor is staying in its same position. You may want to set this if you have multiple selection cursors (like one for main menu item, and one for sub items) in the same scene where one stays at the selected position to indicate the previously selected category, while the other cursor indicating the current moveable selection item."}),"\n",(0,n.jsx)(t.h3,{id:"boundaries-tab",children:(0,n.jsx)(t.code,{children:"[Boundaries] Tab"})}),"\n",(0,n.jsx)(t.p,{children:"The [Boundaries] tab defines the boundaries in which the cursor is allowed to move and the distance per movement step."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Boundaries Tab",src:s(5383).A+"",width:"458",height:"464"})}),"\n",(0,n.jsx)(t.h3,{id:"base-pos-x",children:(0,n.jsx)(t.em,{children:"Base Pos X"})}),"\n",(0,n.jsx)(t.p,{children:"Base position-x (far left) of cursor in pixels units. This will be the starting position X on the screen where the cursor will be placed."}),"\n",(0,n.jsx)(t.h3,{id:"base-pos-y",children:(0,n.jsx)(t.em,{children:"Base Pos Y"})}),"\n",(0,n.jsx)(t.p,{children:"Base position-y (far top) of cursor in pixels units. This will be the starting position Y on the screen where the cursor will be placed."}),"\n",(0,n.jsx)(t.h3,{id:"offset-pos-x",children:(0,n.jsx)(t.em,{children:"Offset Pos X"})}),"\n",(0,n.jsx)(t.p,{children:'Normally you want to leave this as "0". If needed, you can add an offset to the cursor\u2019s x-axis in pixel units. A common use case for setting an offset is when there are inconsistent pixel distances (or steps) while moving the cursor to a specific position. You can dynamically adjust the offset during runtime based on the current cursor index to achieve unequal movement distances.'}),"\n",(0,n.jsx)(t.h3,{id:"offset-pos-y",children:(0,n.jsx)(t.em,{children:"Offset Pos Y"})}),"\n",(0,n.jsx)(t.p,{children:'Normally you want to leave this as "0". If needed, you can add an offset to the cursor\u2019s y-axis in pixel units. A common use case for setting an offset is when there are inconsistent pixel distances (or steps) while moving the cursor to a specific position. You can dynamically adjust the offset during runtime based on the current cursor index to achieve unequal movement distances.'}),"\n",(0,n.jsx)(t.h3,{id:"move-step-x",children:(0,n.jsx)(t.em,{children:"Move Step X"})}),"\n",(0,n.jsx)(t.p,{children:"Defines how many pixels the cursor actor should move in the X axis when d-pad is pressed in horizontal direction."}),"\n",(0,n.jsx)(t.h3,{id:"move-step-y",children:(0,n.jsx)(t.em,{children:"Move Step Y"})}),"\n",(0,n.jsx)(t.p,{children:"Defines how many pixels the cursor actor should move in the Y axis when d-pad is pressed in vertical direction."}),"\n",(0,n.jsx)(t.h3,{id:"max-columns",children:(0,n.jsx)(t.em,{children:"Max Columns"})}),"\n",(0,n.jsx)(t.p,{children:"Defines the maximum columns or steps the cursor is allowed to move in the horizontal direction."}),"\n",(0,n.jsx)(t.h3,{id:"max-rows",children:(0,n.jsx)(t.em,{children:"Max Rows"})}),"\n",(0,n.jsx)(t.p,{children:"Specify the maximum rows or steps the cursor is allowed to move in the vertical direction."}),"\n",(0,n.jsx)(t.h3,{id:"use-scene-collisions-for-moveable-region",children:(0,n.jsx)(t.em,{children:"Use Scene Collisions For Moveable Region"})}),"\n",(0,n.jsx)(t.p,{children:'When this option is enabled, the map collisions of the current scene are used to define the region in which the cursor can move. Paths with non-zero collision values will be blocked. You can also use top/bottom/left/right collisions to allow the cursor to move in one-way direction. You can also use the ladder collision type to "jump" or skip the cursor to the next non-collision tile. Note: The movement step must be constant (i.e., Move Step X/Y specified as variables will be ignored).'}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Use Scene Collisions Example",src:s(5939).A+"",width:"305",height:"214"})}),"\n",(0,n.jsx)(t.p,{children:"For example, in the screenshot above, you\u2019ll see a trash can (or whatever you think it is) isolated from the other items. The cursor can still move into the blank area to the left of the trash can. If you want the cursor to move only on the trash can and not in the blank area, you can set a map collision for the blank area while leaving the position of the trash can collision-free to achieve this behavior."}),"\n",(0,n.jsx)(t.h3,{id:"collision-tile-start-x",children:(0,n.jsx)(t.em,{children:"Collision Tile Start X"})}),"\n",(0,n.jsx)(t.p,{children:"Specify the top-left tile (x-axes) where the scene's collision begins."}),"\n",(0,n.jsx)(t.h3,{id:"collision-tile-start-y",children:(0,n.jsx)(t.em,{children:"Collision Tile Start Y"})}),"\n",(0,n.jsx)(t.p,{children:"Specify the top-left tile (y-axes) where the scene's collision begins."}),"\n",(0,n.jsx)(t.h3,{id:"options-tab",children:(0,n.jsx)(t.code,{children:"[Options] Tab"})}),"\n",(0,n.jsx)(t.p,{children:"The [Options] tab allows you to select various settings to control the appearance and behavior of the selection cursor."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Options Tab",src:s(2615).A+"",width:"457",height:"218"})}),"\n","\n",(0,n.jsx)(t.h3,{id:"smooth-movement",children:(0,n.jsx)(t.em,{children:"Smooth movement"})}),"\n",(0,n.jsx)(t.p,{children:"Enable this option to animate the cursor with easing transition movement."}),"\n",(0,n.jsx)("img",{src:o,style:{width:200},alt:"Smooth Movement Disabled"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Disabled"})}),"\n",(0,n.jsx)("img",{src:r,style:{width:200},alt:"Smooth Movement Enabled"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Enabled"})}),"\n",(0,n.jsx)(t.h3,{id:"reverse-direction-on-end-reached",children:(0,n.jsx)(t.em,{children:"Reverse direction on end reached"})}),"\n",(0,n.jsx)(t.p,{children:"If [Smooth movement] and [Move to opposite side beyond boundary] is enabled, enabling this option will move the cursor with animation to the opposite direction until it reaches the beginning/end of column."}),"\n",(0,n.jsx)("img",{src:a,style:{width:200},alt:"Reverse direction on end reached example"}),"\n",(0,n.jsx)(t.h3,{id:"move-to-opposite-side-beyond-boundary",children:(0,n.jsx)(t.em,{children:"Move to opposite side beyond boundary"})}),"\n",(0,n.jsx)(t.p,{children:"Move the cursor to the beginning or the end of the opposite side in the item list when it moves out-bound of maximum rows/columns."}),"\n",(0,n.jsx)("img",{src:l,style:{width:200},alt:"Move to opposite side example"}),"\n",(0,n.jsx)(t.h3,{id:"bounce-at-dead-end",children:(0,n.jsx)(t.em,{children:"Bounce at dead end"})}),"\n",(0,n.jsx)(t.p,{children:"Enabling this option will play a slight bouncing animation when it reaches the item list boundary or hits a collision when [Use Scene Collisions For Moveable Region] is enabled."}),"\n",(0,n.jsx)("img",{src:c,style:{width:200},alt:"Bounce cursor example"}),"\n",(0,n.jsx)(t.h3,{id:"move-while-d-pad-held",children:(0,n.jsx)(t.em,{children:"Move while D-pad held"})}),"\n",(0,n.jsx)(t.p,{children:"Move the cursor while the D-pad is held."}),"\n",(0,n.jsx)(t.h3,{id:"enable-a-button-held",children:(0,n.jsx)(t.em,{children:"Enable 'A' button held"})}),"\n",(0,n.jsx)(t.p,{children:"Enable 'A' button to be triggered while the button is held."}),"\n",(0,n.jsx)(t.h3,{id:"change-cursor-index-instantly",children:(0,n.jsx)(t.em,{children:"Change cursor index instantly"})}),"\n",(0,n.jsx)(t.p,{children:"When enabled, changes the cursor index instantly when cursor leaves the current position. If disabled, cursor index changes after the position change completes. May be useful if you want to apply pre/post script processing depending on the current cursor index."}),"\n",(0,n.jsx)(t.h3,{id:"show-cursor-above-overlay",children:(0,n.jsx)(t.em,{children:"Show cursor above overlay"})}),"\n",(0,n.jsx)(t.p,{children:"Shows the cursor actor above overlay."}),"\n",(0,n.jsx)(t.h3,{id:"return-values-tab",children:(0,n.jsx)(t.code,{children:"[Return Values] Tab"})}),"\n",(0,n.jsx)(t.p,{children:"This section allows you to specifiy the variables to store the current index of the cursor and the identifier of button that was pressed."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Options Tab",src:s(3530).A+"",width:"457",height:"189"})}),"\n",(0,n.jsx)(t.p,{children:"Cursor index is layed out from left to right like in the screen show below. Index is automatically assigned when you set the boundaries (max column and max rows)."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Options Tab",src:s(553).A+"",width:"286",height:"108"})}),"\n",(0,n.jsx)(t.h3,{id:"store-ab-results-to",children:(0,n.jsx)(t.em,{children:"Store A/B results to"})}),"\n",(0,n.jsx)(t.p,{children:"Variable to store the A/B button press results. When user presses the B button, results stores 0. If A button is pressed, results stores 1. When user is not pressing A or B buttons, results stores -1."}),"\n",(0,n.jsx)(t.h3,{id:"store-current-index-to",children:(0,n.jsx)(t.em,{children:"Store current index to"})}),"\n",(0,n.jsx)(t.p,{children:"Variable to store the current cursor index. When cursor hover overs an item, current item index is stored to this variable, starting from index 0."})]})}function v(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(x,{...e})}):x(e)}},7259:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/actor_and_states_tab-a1a22e9a67718a475088300ce1870ffd.png"},5383:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/boundaries_tab-a82fcdce42308f97027192938d8aaacb.png"},2194:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/cursor_controller_overview_480p-e292ce4d45812813ffb2819d996c8658.gif"},553:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/cursor_index_example-9f1c67367b916489441f19e9524c18b0.png"},2615:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/options_tab-1892219e7f86b057157f8951912bb3d8.png"},3530:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/return_values_tab-da365392771fc5674384327ee0b799e8.png"},5939:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/use_mappings_example-b7490b854aea9990e983d933c796e152.png"},8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>a});var n=s(6540);const i={},o=n.createContext(i);function r(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);